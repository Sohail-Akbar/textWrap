<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Fabric.js Text Warp with Multiple Fonts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        #controls {
            margin-bottom: 10px;
        }

        #text_controls {
            margin-bottom: 15px;
        }
    </style>
</head>

<body>
    <div id="text_controls">
        <input type="text" id="text_input" placeholder="Enter text" />
        <button id="add_text_btn">Add Text</button>
    </div>

    <div>
        <label for="font_select">Font</label>
        <select id="font_select">
            <option value="LoveDays-2v7Oe.ttf">Love Days</option>
            <option value="Notable-Regular.ttf">Notable</option>
            <option value="LuckiestGuy-Regular.ttf">Luckiest Guy</option>
            <option value="Peace Sans.otf">Peace Sans</option>
            <option value="XRBNIeS7Tvw69jxW7GvB9iBDHBqWo5.ttf">11</option>
            <option value="tsLmbIhqe6840ohWr468AFk0BlqGPT.ttf">11</option>
        </select>
    </div>

    <div id="controls">
        <select id="arc_type">
            <option value="">Select</option>
            <option value="WARP_ARC">Arc</option>
            <option value="WARP_ARC_LOWER">Arc Lower</option>
            <option value="WARP_ARC_UPPER">Arc Upper</option>
            <option value="WARP_ARCH">Arch</option>
            <option value="WARP_BULGE">Bulge</option>
            <option value="WARP_FLAG">Flag</option>
            <option value="WARP_FISH">Fish</option>
            <option value="WARP_RISE">Rise</option>
            <option value="WARP_INFLATE">Inflate</option>
            <option value="WARP_SQUEEZE">Squeeze</option>
            <option value="WARP_WAVE_LOWER">Wave Lower</option>
            <option value="WARP_WAVE_UPPER">Wave Upper</option>
            <option value="WARP_CIRCLE">Circle</option>
        </select>

        <div>
            <label for="bend_control">Bend</label>
            <input type="range" min="-100" value="0" max="100" id="bend_control">
            <button value="bend_control">Reset</button>
        </div>
        <div>
            <label for="horizontal_control">Horizontal Distort</label>
            <input type="range" min="-100" value="0" max="100" id="horizontal_control">
            <button value="horizontal_control">Reset</button>
        </div>
        <div>
            <label for="vertical_control">Vertical Distort</label>
            <input type="range" min="-100" value="0" max="100" id="vertical_control">
            <button value="vertical_control">Reset</button>
        </div>
    </div>
    <div>
        <label for="fill_color">Fill</label>
        <input type="color" id="fill_color" value="#000000">
    </div>

    <div>
        <label for="stroke_color">Outline</label>
        <input type="color" id="stroke_color" value="#ff0000">
        <label for="stroke_width">Width</label>
        <input type="range" id="stroke_width" min="0" max="10" value="0">
    </div>

    <div>
        <label for="font_size">Font Size</label>
        <input type="number" id="font_size" value="72" min="10" max="200">
    </div>

    <div>
        <label for="rotation">Rotate</label>
        <input type="range" id="rotation" min="0" max="360" value="0">
    </div>

    <div>
        <label for="letter_spacing">Letter Spacing</label>
        <input type="range" id="letter_spacing" min="-200" max="200" value="0">
    </div>

    <canvas id="canvas" width="800" height="400" style="border:1px solid #ccc"></canvas>

    <script src="./path-wrap.js"></script>
    <script>
        const canvas = new fabric.Canvas("canvas");

        const textInput = document.querySelector('#text_input');
        const addTextBtn = document.querySelector('#add_text_btn');
        const fontSelect = document.querySelector('#font_select');

        const bend_control = document.querySelector('#bend_control');
        const horizontal_control = document.querySelector('#horizontal_control');
        const vertical_control = document.querySelector('#vertical_control');
        const arc_type = document.querySelector('#arc_type');

        const fillColor = document.querySelector('#fill_color');
        const strokeColor = document.querySelector('#stroke_color');
        const strokeWidth = document.querySelector('#stroke_width');
        const fontSizeInput = document.querySelector('#font_size');
        const rotationInput = document.querySelector('#rotation');
        const letterSpacingInput = document.querySelector('#letter_spacing');

        // âœ… Fix: live text editing
        textInput.addEventListener("input", updateActiveText);

        // Generate SVG path from text using opentype.js
        function generateSVGText({
            text,
            alignment = "center",
            fontSize = 50,
            fontStyle,
            letterSpacing = 2,
            lineHeight = 1.2
        }) {
            return new Promise((resolve, reject) => {
                opentype.load(fontStyle, function (err, font) {
                    if (err) return reject(err);

                    const boxWidth = 5000;
                    const lineGap = fontSize * lineHeight;
                    let yCursor = 0;
                    const combinedCommands = [];

                    const lines = text.split('\n');

                    lines.forEach(line => {
                        let xPosition = 0;
                        const lineCommands = [];
                        const glyphs = [];

                        for (const char of line) {
                            const glyph = font.charToGlyph(char);
                            glyphs.push(glyph);
                            xPosition += glyph.advanceWidth * (fontSize / font.unitsPerEm) + letterSpacing;
                        }

                        const lineWidth = xPosition - letterSpacing;
                        let lineXOffset = 0;
                        if (alignment === 'center') {
                            lineXOffset = (boxWidth - lineWidth) / 2;
                        } else if (alignment === 'right') {
                            lineXOffset = boxWidth - lineWidth - 10;
                        } else {
                            lineXOffset = 10;
                        }

                        let x = lineXOffset;

                        for (const glyph of glyphs) {
                            const path = glyph.getPath(x, yCursor, fontSize);
                            lineCommands.push(...path.commands);
                            x += glyph.advanceWidth * (fontSize / font.unitsPerEm) + letterSpacing;
                        }

                        combinedCommands.push(...lineCommands);
                        yCursor += lineGap;
                    });

                    const extraPadding = fontSize * 3;
                    const boxHeight = yCursor + extraPadding;

                    const finalPath = new opentype.Path();
                    finalPath.commands = combinedCommands;

                    const { x1, y1, x2, y2 } = finalPath.getBoundingBox();
                    const textWidth = x2 - x1;
                    const textHeight = y2 - y1;

                    const xOffset = (boxWidth - textWidth) / 2 - x1;
                    const yOffset = (boxHeight - textHeight) / 2 - y1;

                    finalPath.commands.forEach(cmd => {
                        if (cmd.x !== undefined) cmd.x += xOffset;
                        if (cmd.x1 !== undefined) cmd.x1 += xOffset;
                        if (cmd.x2 !== undefined) cmd.x2 += xOffset;

                        if (cmd.y !== undefined) cmd.y += yOffset;
                        if (cmd.y1 !== undefined) cmd.y1 += yOffset;
                        if (cmd.y2 !== undefined) cmd.y2 += yOffset;
                    });

                    const svgPathData = finalPath.toPathData();
                    resolve({
                        svgPath: svgPathData,
                        svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${boxWidth} ${boxHeight}">
                                <path d="${svgPathData}" />
                              </svg>`
                    });
                });
            });
        }

        // Helper: get path bounds
        function getPathBounds(path) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(cmd => {
                let pts = cmd.slice(1);
                for (let i = 0; i < pts.length; i += 2) {
                    const x = pts[i], y = pts[i + 1];
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                }
            });
            return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
        }

        // Warp active object
        function changePath() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj || !activeObj.customBaseD) return;

            const p = new Path(activeObj.customBaseD);
            p.warp({
                type: arc_type.value,
                bend: (bend_control.value / 100) || 0,
                distortV: (horizontal_control.value / 100) || 0,
                distortH: (vertical_control.value / 100) || 0,
            });

            const newPath = new fabric.Path(`<path>${p.output()}</path>`);
            const bounds = getPathBounds(newPath.path);

            activeObj.set({
                path: newPath.path,
                width: bounds.width,
                height: bounds.height,
                pathOffset: {
                    x: bounds.left + bounds.width / 2,
                    y: bounds.top + bounds.height / 2
                },
                customWarp: {
                    type: arc_type.value,
                    bend: bend_control.value,
                    distortH: horizontal_control.value,
                    distortV: vertical_control.value
                }
            });

            activeObj.setCoords();
            canvas.requestRenderAll();
        }

        // Add text
        addTextBtn.addEventListener("click", () => {
            const textVal = textInput.value.trim();
            if (!textVal) return alert("Please enter some text!");

            generateSVGText({
                text: textVal,
                alignment: "center",
                fontSize: parseInt(fontSizeInput.value, 10),
                fontStyle: "./" + fontSelect.value,
                letterSpacing: parseInt(letterSpacingInput.value, 10),
                lineHeight: 1.2
            }).then(svgContent => {
                const textPath = new fabric.Path(svgContent.svgPath, {
                    left: 300,
                    top: 200,
                    fill: fillColor.value,
                    stroke: strokeColor.value,
                    strokeWidth: parseInt(strokeWidth.value, 10),
                    originX: "center",
                    originY: "center",
                    selectable: true,
                    customBaseD: svgContent.svgPath,
                    customFontSize: parseInt(fontSizeInput.value, 10),
                    customLetterSpacing: parseInt(letterSpacingInput.value, 10)
                });

                canvas.add(textPath).setActiveObject(textPath);
                canvas.requestRenderAll();
            });
        });

        // Update active text
        function updateActiveText() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            const textVal = textInput.value.trim();
            if (!textVal) return;

            generateSVGText({
                text: textVal,
                alignment: "center",
                fontSize: parseInt(fontSizeInput.value, 10),
                fontStyle: "./" + fontSelect.value,
                letterSpacing: parseInt(letterSpacingInput.value, 10),
                lineHeight: 1.2
            }).then(svgContent => {
                // new path from generated SVG
                const newPath = new fabric.Path(svgContent.svgPath);

                obj.customBaseD = svgContent.svgPath; // store base path

                // calculate bounds
                const bounds = getPathBounds(newPath.path);

                obj.set({
                    path: newPath.path,
                    width: bounds.width,
                    height: bounds.height,
                    pathOffset: {
                        x: bounds.left + bounds.width / 2,
                        y: bounds.top + bounds.height / 2
                    }
                });

                changePath(); // re-apply warp if selected
                obj.setCoords();
                canvas.requestRenderAll();
            });
        }


        // Controls events
        bend_control.addEventListener('input', changePath);
        horizontal_control.addEventListener('input', changePath);
        vertical_control.addEventListener('input', changePath);
        arc_type.addEventListener('change', changePath);

        // Reset buttons
        document.addEventListener('click', function (e) {
            if (e.target instanceof HTMLButtonElement && e.target.value) {
                window[e.target.value].value = 0;
                changePath();
            }
        });

        fillColor.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("fill", fillColor.value);
            canvas.requestRenderAll();
        });

        strokeColor.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("stroke", strokeColor.value);
            canvas.requestRenderAll();
        });

        strokeWidth.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("strokeWidth", parseInt(strokeWidth.value, 10));
            canvas.requestRenderAll();
        });

        fontSizeInput.addEventListener("input", updateActiveText);
        letterSpacingInput.addEventListener("input", updateActiveText);
        fontSelect.addEventListener("change", updateActiveText);

        rotationInput.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("angle", parseInt(rotationInput.value, 10));
            obj.setCoords();
            canvas.requestRenderAll();
        });
    </script>
</body>

</html>