<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Fabric.js Text Warp with Save & Load</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
            padding: 15px;
        }

        #sidebar {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            height: calc(100vh - 30px);
            overflow-y: auto;
        }

        #canvas-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            height: calc(100vh - 30px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .control-group h6 {
            color: #495057;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .form-label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .btn-reset {
            font-size: 0.8rem;
            padding: 2px 8px;
        }

        #jsonOutput {
            font-size: 0.8rem;
            max-height: 150px;
        }

        .btn-group-vertical {
            width: 100%;
        }

        .btn-group-vertical .btn {
            text-align: left;
        }

        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-4 col-lg-3">
                <div id="sidebar">
                    <h4 class="mb-4">Text Warp Editor</h4>

                    <!-- Text Input Section -->
                    <div class="control-group">
                        <h6>Text Input</h6>
                        <div class="mb-3">
                            <label for="text_input" class="form-label">Text Content</label>
                            <input type="text" class="form-control" id="text_input" placeholder="Enter text">
                        </div>
                        <div class="mb-3">
                            <label for="font_select" class="form-label">Font</label>
                            <select class="form-select" id="font_select">
                                <option value="LoveDays-2v7Oe.ttf">Love Days</option>
                                <option value="Notable-Regular.ttf">Notable</option>
                                <option value="LuckiestGuy-Regular.ttf">Luckiest Guy</option>
                                <option value="Peace Sans.otf">Peace Sans</option>
                                <option value="XRBNIeS7Tvw69jxW7GvB9iBDHBqWo5.ttf">Font 5</option>
                                <option value="tsLmbIhqe6840ohWr468AFk0BlqGPT.ttf">Font 6</option>
                            </select>
                        </div>
                        <button id="add_text_btn" class="btn btn-primary w-100">Add Text</button>
                    </div>

                    <!-- Warp Controls -->
                    <div class="control-group">
                        <h6>Warp Controls</h6>
                        <div class="mb-3">
                            <label for="arc_type" class="form-label">Warp Type</label>
                            <select class="form-select" id="arc_type">
                                <option value="">Select</option>
                                <option value="WARP_ARC">Arc</option>
                                <option value="WARP_ARC_LOWER">Arc Lower</option>
                                <option value="WARP_ARC_UPPER">Arc Upper</option>
                                <option value="WARP_ARCH">Arch</option>
                                <option value="WARP_BULGE">Bulge</option>
                                <option value="WARP_FLAG">Flag</option>
                                <option value="WARP_FISH">Fish</option>
                                <option value="WARP_RISE">Rise</option>
                                <option value="WARP_INFLATE">Inflate</option>
                                <option value="WARP_SQUEEZE">Squeeze</option>
                                <option value="WARP_WAVE_LOWER">Wave Lower</option>
                                <option value="WARP_WAVE_UPPER">Wave Upper</option>
                                <option value="WARP_CIRCLE">Circle</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label for="bend_control" class="form-label">Bend: <span id="bend_value">0</span></label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range flex-grow-1" min="-100" value="0" max="100"
                                    id="bend_control">
                                <button class="btn btn-outline-secondary btn-reset ms-2"
                                    value="bend_control">Reset</button>
                            </div>
                        </div>

                        <div class="mb-3">
                            <label for="horizontal_control" class="form-label">Horizontal Distort: <span
                                    id="horizontal_value">0</span></label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range flex-grow-1" min="-100" value="0" max="100"
                                    id="horizontal_control">
                                <button class="btn btn-outline-secondary btn-reset ms-2"
                                    value="horizontal_control">Reset</button>
                            </div>
                        </div>

                        <div class="mb-3">
                            <label for="vertical_control" class="form-label">Vertical Distort: <span
                                    id="vertical_value">0</span></label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range flex-grow-1" min="-100" value="0" max="100"
                                    id="vertical_control">
                                <button class="btn btn-outline-secondary btn-reset ms-2"
                                    value="vertical_control">Reset</button>
                            </div>
                        </div>
                    </div>

                    <!-- Appearance Controls -->
                    <div class="control-group">
                        <h6>Appearance</h6>
                        <div class="row mb-3">
                            <div class="col-6">
                                <label for="fill_color" class="form-label">Fill Color</label>
                                <input type="color" class="form-control form-control-color" id="fill_color"
                                    value="#000000" title="Choose fill color">
                            </div>
                            <div class="col-6">
                                <label for="stroke_color" class="form-label">Outline Color</label>
                                <input type="color" class="form-control form-control-color" id="stroke_color"
                                    value="#ff0000" title="Choose outline color">
                            </div>
                        </div>

                        <div class="mb-3">
                            <label for="stroke_width" class="form-label">Outline Width: <span
                                    id="stroke_width_value">0</span></label>
                            <input type="range" class="form-range" id="stroke_width" min="0" max="10" value="0">
                        </div>

                        <div class="mb-3">
                            <label for="font_size" class="form-label">Font Size</label>
                            <input type="number" class="form-control" id="font_size" value="72" min="10" max="200">
                        </div>

                        <div class="mb-3">
                            <label for="rotation" class="form-label">Rotation: <span
                                    id="rotation_value">0Â°</span></label>
                            <input type="range" class="form-range" id="rotation" min="0" max="360" value="0">
                        </div>

                        <div class="mb-3">
                            <label for="letter_spacing" class="form-label">Letter Spacing: <span
                                    id="letter_spacing_value">0</span></label>
                            <input type="range" class="form-range" id="letter_spacing" min="-200" max="200" value="0">
                        </div>
                    </div>

                    <!-- Save/Load Section -->
                    <div class="control-group">
                        <h6>Project</h6>
                        <div class="d-grid gap-2">
                            <button id="saveCanvas" class="btn btn-success">Save</button>
                            <button id="loadCanvas" class="btn btn-info">Load</button>
                        </div>

                        <div class="mt-3">
                            <label class="form-label">JSON Output</label>
                            <pre id="jsonOutput" class="bg-light p-2 rounded"
                                style="white-space: pre-wrap; max-height: 150px; overflow:auto;"></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="col-md-8 col-lg-9">
                <div id="canvas-container">
                    <canvas id="canvas" width="800" height="400"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script src="./path-wrap.js"></script>
    <script>
        const canvas = new fabric.Canvas("canvas");

        const textInput = document.querySelector('#text_input');
        const addTextBtn = document.querySelector('#add_text_btn');
        const fontSelect = document.querySelector('#font_select');

        const bend_control = document.querySelector('#bend_control');
        const horizontal_control = document.querySelector('#horizontal_control');
        const vertical_control = document.querySelector('#vertical_control');
        const arc_type = document.querySelector('#arc_type');

        const fillColor = document.querySelector('#fill_color');
        const strokeColor = document.querySelector('#stroke_color');
        const strokeWidth = document.querySelector('#stroke_width');
        const fontSizeInput = document.querySelector('#font_size');
        const rotationInput = document.querySelector('#rotation');
        const letterSpacingInput = document.querySelector('#letter_spacing');

        // Update value displays
        function updateValueDisplays() {
            document.getElementById('bend_value').textContent = bend_control.value;
            document.getElementById('horizontal_value').textContent = horizontal_control.value;
            document.getElementById('vertical_value').textContent = vertical_control.value;
            document.getElementById('stroke_width_value').textContent = strokeWidth.value;
            document.getElementById('rotation_value').textContent = rotationInput.value + 'Â°';
            document.getElementById('letter_spacing_value').textContent = letterSpacingInput.value;
        }

        // Initialize value displays
        updateValueDisplays();

        // â live text editing
        textInput.addEventListener("input", updateActiveText);

        // â Extend fabric Object to save custom props
        fabric.Object.prototype.toObject = (function (toObject) {
            return function (propertiesToInclude) {
                return toObject.call(this, (propertiesToInclude || []).concat([
                    "customBaseD",
                    "customWarp",
                    "customFontSize",
                    "customLetterSpacing"
                ]));
            };
        })(fabric.Object.prototype.toObject);

        // â Generate SVG Path from Text
        function generateSVGText({ text, alignment = "center", fontSize = 50, fontStyle, letterSpacing = 2, lineHeight = 1.2 }) {
            return new Promise((resolve, reject) => {
                opentype.load(fontStyle, function (err, font) {
                    if (err) return reject(err);

                    const boxWidth = 5000;
                    const lineGap = fontSize * lineHeight;
                    let yCursor = 0;
                    const combinedCommands = [];
                    const lines = text.split('\n');

                    lines.forEach(line => {
                        let xPosition = 0;
                        const lineCommands = [];
                        const glyphs = [];

                        for (const char of line) {
                            const glyph = font.charToGlyph(char);
                            glyphs.push(glyph);
                            xPosition += glyph.advanceWidth * (fontSize / font.unitsPerEm) + letterSpacing;
                        }

                        const lineWidth = xPosition - letterSpacing;
                        let lineXOffset = alignment === 'center' ? (boxWidth - lineWidth) / 2 : alignment === 'right' ? boxWidth - lineWidth - 10 : 10;

                        let x = lineXOffset;

                        for (const glyph of glyphs) {
                            const path = glyph.getPath(x, yCursor, fontSize);
                            lineCommands.push(...path.commands);
                            x += glyph.advanceWidth * (fontSize / font.unitsPerEm) + letterSpacing;
                        }

                        combinedCommands.push(...lineCommands);
                        yCursor += lineGap;
                    });

                    const extraPadding = fontSize * 3;
                    const boxHeight = yCursor + extraPadding;
                    const finalPath = new opentype.Path();
                    finalPath.commands = combinedCommands;

                    const { x1, y1, x2, y2 } = finalPath.getBoundingBox();
                    const textWidth = x2 - x1;
                    const textHeight = y2 - y1;

                    const xOffset = (boxWidth - textWidth) / 2 - x1;
                    const yOffset = (boxHeight - textHeight) / 2 - y1;

                    finalPath.commands.forEach(cmd => {
                        if (cmd.x !== undefined) cmd.x += xOffset;
                        if (cmd.x1 !== undefined) cmd.x1 += xOffset;
                        if (cmd.x2 !== undefined) cmd.x2 += xOffset;
                        if (cmd.y !== undefined) cmd.y += yOffset;
                        if (cmd.y1 !== undefined) cmd.y1 += yOffset;
                        if (cmd.y2 !== undefined) cmd.y2 += yOffset;
                    });

                    const svgPathData = finalPath.toPathData();
                    resolve({
                        svgPath: svgPathData,
                        svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${boxWidth} ${boxHeight}">
                    <path d="${svgPathData}" />
                  </svg>`
                    });
                });
            });
        }

        // Helper: get path bounds
        function getPathBounds(path) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(cmd => {
                let pts = cmd.slice(1);
                for (let i = 0; i < pts.length; i += 2) {
                    const x = pts[i], y = pts[i + 1];
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                }
            });
            return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
        }

        // â Warp active object
        function changePath() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj || !activeObj.customBaseD) return;

            const p = new Path(activeObj.customBaseD);
            p.warp({
                type: arc_type.value,
                bend: (bend_control.value / 100) || 0,
                distortV: (horizontal_control.value / 100) || 0,
                distortH: (vertical_control.value / 100) || 0,
            });

            const newPath = new fabric.Path(`<path>${p.output()}</path>`);
            const bounds = getPathBounds(newPath.path);

            activeObj.set({
                path: newPath.path,
                width: bounds.width,
                height: bounds.height,
                pathOffset: { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 },
                customWarp: {
                    type: arc_type.value,
                    bend: bend_control.value,
                    distortH: horizontal_control.value,
                    distortV: vertical_control.value
                }
            });

            activeObj.setCoords();
            canvas.requestRenderAll();
            updateValueDisplays();
        }

        // Add text
        addTextBtn.addEventListener("click", () => {
            const textVal = textInput.value.trim();
            if (!textVal) return alert("Please enter some text!");

            generateSVGText({
                text: textVal,
                alignment: "center",
                fontSize: parseInt(fontSizeInput.value, 10),
                fontStyle: "./" + fontSelect.value,
                letterSpacing: parseInt(letterSpacingInput.value, 10),
                lineHeight: 1.2
            }).then(svgContent => {
                const textPath = new fabric.Path(svgContent.svgPath, {
                    left: 300,
                    top: 200,
                    fill: fillColor.value,
                    stroke: strokeColor.value,
                    strokeWidth: parseInt(strokeWidth.value, 10),
                    originX: "center",
                    originY: "center",
                    selectable: true,
                    customBaseD: svgContent.svgPath,
                    customFontSize: parseInt(fontSizeInput.value, 10),
                    customLetterSpacing: parseInt(letterSpacingInput.value, 10),
                    strokePosition: "outside",
                    strokeUniform: true,
                    strokeLineJoin: "round",
                    strokeMiterLimit: 2,
                    paintFirst: 'stroke',
                });

                canvas.add(textPath).setActiveObject(textPath);
                canvas.requestRenderAll();
            });
        });

        // Update active text
        function updateActiveText() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            const textVal = textInput.value.trim();
            if (!textVal) return;

            generateSVGText({
                text: textVal,
                alignment: "center",
                fontSize: parseInt(fontSizeInput.value, 10),
                fontStyle: "./" + fontSelect.value,
                letterSpacing: parseInt(letterSpacingInput.value, 10),
                lineHeight: 1.2
            }).then(svgContent => {
                const newPath = new fabric.Path(svgContent.svgPath);
                obj.customBaseD = svgContent.svgPath;
                const bounds = getPathBounds(newPath.path);
                obj.set({
                    path: newPath.path,
                    width: bounds.width,
                    height: bounds.height,
                    pathOffset: { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }
                });
                changePath();
                obj.setCoords();
                canvas.requestRenderAll();
            });
        }

        // Controls events
        bend_control.addEventListener('input', changePath);
        horizontal_control.addEventListener('input', changePath);
        vertical_control.addEventListener('input', changePath);
        arc_type.addEventListener('change', changePath);

        // Reset buttons
        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('btn-reset')) {
                const controlId = e.target.value;
                const control = document.getElementById(controlId);
                if (control) {
                    control.value = 0;
                    changePath();
                }
            }
        });

        fillColor.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("fill", fillColor.value);
            canvas.requestRenderAll();
        });

        strokeColor.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("stroke", strokeColor.value);
            canvas.requestRenderAll();
        });

        strokeWidth.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("strokeWidth", parseInt(strokeWidth.value, 10));
            canvas.requestRenderAll();
            updateValueDisplays();
        });

        fontSizeInput.addEventListener("input", updateActiveText);
        letterSpacingInput.addEventListener("input", updateActiveText);
        fontSelect.addEventListener("change", updateActiveText);

        rotationInput.addEventListener("input", () => {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            obj.set("angle", parseInt(rotationInput.value, 10));
            obj.setCoords();
            canvas.requestRenderAll();
            updateValueDisplays();
        });

        // â Save button
        document.querySelector("#saveCanvas").addEventListener("click", () => {
            const json = JSON.stringify(canvas.toJSON(), null, 2);
            document.querySelector("#jsonOutput").textContent = json;
            localStorage.setItem("fabricCanvas", json);
        });

        // â Load button
        document.querySelector("#loadCanvas").addEventListener("click", () => {
            const saved = localStorage.getItem("fabricCanvas");
            if (!saved) return alert("No saved canvas found!");
            canvas.loadFromJSON(saved, () => {
                canvas.renderAll();
                canvas.getObjects().forEach(obj => {
                    if (obj.customWarp && obj.customBaseD) {
                        const p = new Path(obj.customBaseD);
                        p.warp({
                            type: obj.customWarp.type,
                            bend: (obj.customWarp.bend / 100) || 0,
                            distortV: (obj.customWarp.distortV / 100) || 0,
                            distortH: (obj.customWarp.distortH / 100) || 0,
                        });
                        const newPath = new fabric.Path(`<path>${p.output()}</path>`);
                        const bounds = getPathBounds(newPath.path);
                        obj.set({
                            path: newPath.path,
                            width: bounds.width,
                            height: bounds.height,
                            pathOffset: { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }
                        });
                        obj.setCoords();
                    }
                });
                alert("Canvas loaded!");
                canvas.renderAll();
            });
        });

    </script>
</body>

</html>